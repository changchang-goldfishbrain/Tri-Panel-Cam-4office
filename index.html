<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0, viewport-fit=cover" />
    <title>Tri-Grid Cam</title>
    
    <!-- Mobile Web App Config -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: white;
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
            height: 100dvh; /* Use dynamic viewport height */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* The Grid Container */
        #grid-container {
            flex: 1;
            display: grid;
            grid-template-rows: 1fr 1fr 1fr; /* Top, Middle, Bottom */
            width: 100%;
            position: relative;
        }

        /* Individual Slots */
        .grid-slot {
            position: relative;
            overflow: hidden;
            background-color: #1a1a1a;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .grid-slot:last-child {
            border-bottom: none;
        }

        /* The Video Element (Moves between slots) */
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            inset: 0;
            z-index: 10;
        }

        /* Captured Image (Replaces video) */
        .captured-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            inset: 0;
            z-index: 20;
            display: block;
        }

        /* Active Slot Indicator (Optional highlight) */
        .slot-active::after {
            content: '';
            position: absolute;
            inset: 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            pointer-events: none;
            z-index: 30;
        }

        /* Animations */
        @keyframes flash {
            0% { background-color: white; opacity: 0; }
            20% { opacity: 0.6; }
            100% { opacity: 0; }
        }
        .flash-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 50;
        }
        .animate-flash {
            animation: flash 0.3s ease-out;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none; /* Let clicks pass through to grid if needed */
            z-index: 40;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: env(safe-area-inset-bottom, 24px);
        }

        /* Controls */
        .control-btn {
            pointer-events: auto;
            transition: transform 0.1s;
        }
        .control-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <!-- Main App Area -->
    <div id="grid-container">
        <!-- Slots will be injected here -->
        <div id="slot-0" class="grid-slot" onclick="handleSlotClick(0)"></div>
        <div id="slot-1" class="grid-slot" onclick="handleSlotClick(1)"></div>
        <div id="slot-2" class="grid-slot" onclick="handleSlotClick(2)"></div>
    </div>

    <!-- Video Element (Initially detached or in slot 0) -->
    <video id="videoElement" autoplay playsinline muted style="display: none;"></video>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 bg-black flex flex-col items-center justify-center pointer-events-auto z-50">
            <h1 class="text-3xl font-light tracking-widest mb-2">TRI-GRID</h1>
            <p class="text-zinc-500 text-xs mb-8 tracking-wider">VERTICAL COLLAGE CAM</p>
            <button onclick="startCamera()" class="bg-white text-black px-8 py-3 rounded-full font-bold flex items-center gap-2 hover:bg-zinc-200 transition-colors">
                <i data-lucide="camera" class="w-5 h-5"></i>
                開始拍攝
            </button>
        </div>

        <!-- Controls (Hidden initially) -->
        <div id="controls" class="hidden w-full px-10 py-6 flex justify-between items-center bg-gradient-to-t from-black/80 to-transparent">
            
            <!-- Undo / Back -->
            <button onclick="undo()" class="control-btn text-white/80 p-4 rounded-full bg-black/20 backdrop-blur-md hover:bg-white/20">
                <i data-lucide="rotate-ccw" class="w-6 h-6"></i>
            </button>

            <!-- Shutter Button -->
            <button id="shutter-btn" onclick="capture()" class="control-btn w-20 h-20 rounded-full border-4 border-white flex items-center justify-center shadow-lg shadow-black/30">
                <div class="w-16 h-16 bg-white rounded-full"></div>
            </button>

            <!-- Done / Check (Shows when finished) -->
            <button id="done-btn" onclick="finish()" class="control-btn text-white p-4 rounded-full bg-green-500/80 backdrop-blur-md hidden">
                <i data-lucide="check" class="w-8 h-8"></i>
            </button>

            <!-- Placeholder for spacing when Done is hidden -->
            <div id="spacer-right" class="w-14"></div>
        </div>

        <!-- Result Actions (Hidden initially) -->
        <div id="result-actions" class="hidden absolute bottom-0 w-full p-6 pb-12 bg-black/90 backdrop-blur-xl border-t border-white/10 flex flex-col gap-3 pointer-events-auto z-50 animate-[slideUp_0.3s_ease-out]">
            <p class="text-center text-zinc-400 text-xs mb-2">預覽模式</p>
            <button onclick="downloadCollage()" class="w-full bg-white text-black py-4 rounded-xl font-bold flex items-center justify-center gap-2">
                <i data-lucide="download" class="w-5 h-5"></i>
                儲存照片
            </button>
            <button onclick="resetApp()" class="w-full bg-zinc-800 text-white py-4 rounded-xl font-medium flex items-center justify-center gap-2">
                <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                重新開始
            </button>
        </div>
    </div>

    <!-- Hidden Canvas for processing -->
    <canvas id="processCanvas" class="hidden"></canvas>

    <script>
        // --- State ---
        let stream = null;
        let currentSlot = 0; // 0, 1, 2
        let images = [null, null, null]; // Stores Data URLs
        const totalSlots = 3;

        // Elements
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('processCanvas');
        const uiStart = document.getElementById('start-screen');
        const uiControls = document.getElementById('controls');
        const uiResult = document.getElementById('result-actions');
        const shutterBtn = document.getElementById('shutter-btn');
        const doneBtn = document.getElementById('done-btn');
        const spacerRight = document.getElementById('spacer-right');
        const slots = [
            document.getElementById('slot-0'),
            document.getElementById('slot-1'),
            document.getElementById('slot-2')
        ];

        // --- Core Functions ---

        async function startCamera() {
            try {
                // Request higher resolution for better crop quality
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                video.style.display = 'block';
                
                // Wait for video to be ready
                video.onloadedmetadata = () => {
                    video.play();
                    uiStart.classList.add('hidden');
                    uiControls.classList.remove('hidden');
                    updateActiveSlot();
                };

            } catch (err) {
                console.error(err);
                alert('無法啟動相機，請檢查權限。');
            }
        }

        function updateActiveSlot() {
            // Remove video from wherever it is
            if (video.parentElement) {
                video.parentElement.removeChild(video);
            }

            // Clean up UI
            shutterBtn.classList.remove('hidden');
            doneBtn.classList.add('hidden');
            spacerRight.classList.remove('hidden');

            // If we have slots left
            if (currentSlot < totalSlots) {
                const slotEl = slots[currentSlot];
                
                // Remove existing image if any (for retakes)
                const existingImg = slotEl.querySelector('.captured-img');
                if (existingImg) existingImg.remove();

                // Add video to current slot
                slotEl.appendChild(video);
                
                // Highlight
                slots.forEach(s => s.classList.remove('slot-active'));
                slotEl.classList.add('slot-active');
            } else {
                // All slots full
                video.pause();
                shutterBtn.classList.add('hidden');
                doneBtn.classList.remove('hidden');
                spacerRight.classList.add('hidden');
            }
        }

        function capture() {
            if (currentSlot >= totalSlots) return;

            const slotEl = slots[currentSlot];
            
            // Visual Flash
            const flash = document.createElement('div');
            flash.className = 'flash-overlay animate-flash';
            slotEl.appendChild(flash);
            setTimeout(() => flash.remove(), 500);

            // 1. Calculate Crop
            // The video is object-fit: cover inside the slot.
            // We need to draw exactly what the user sees onto a canvas.
            
            const rect = slotEl.getBoundingClientRect();
            const slotWidth = rect.width;
            const slotHeight = rect.height;
            const slotAspect = slotWidth / slotHeight;

            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const videoAspect = videoWidth / videoHeight;

            let renderW, renderH, offsetX, offsetY;

            // Logic matching object-fit: cover
            if (slotAspect > videoAspect) {
                // Slot is wider than video (relative to height) -> Video fills width, cropped top/bottom? 
                // Wait: Cover means fill the container.
                // If Slot is 'more landscape' than video, we fit width and crop height? No.
                // If Slot (e.g. 3:1) is wider than Video (16:9), we scale video to match Slot Width, and crop height.
                
                // Actually easier logic:
                // Scale factor to make the SMALLER dimension match the container
                const scale = Math.max(slotWidth / videoWidth, slotHeight / videoHeight);
                
                // But we want to crop the SOURCE video, not scale the canvas.
                // Let's project the slot dimensions back onto the video source coordinates.
                
                if (videoAspect > slotAspect) {
                     // Video is wider than slot. Height matches (scaled). Crop sides.
                     // Source Height = Video Height
                     // Source Width = Video Height * SlotAspect
                     const srcH = videoHeight;
                     const srcW = videoHeight * slotAspect;
                     const srcX = (videoWidth - srcW) / 2;
                     const srcY = 0;
                     
                     renderToCanvas(srcX, srcY, srcW, srcH);
                } else {
                     // Video is taller than slot. Width matches. Crop top/bottom.
                     const srcW = videoWidth;
                     const srcH = videoWidth / slotAspect;
                     const srcX = 0;
                     const srcY = (videoHeight - srcH) / 2;
                     
                     renderToCanvas(srcX, srcY, srcW, srcH);
                }

            } else {
                 // Slot is narrower/taller. 
                 // Same logic covers all cases actually:
                 if (videoAspect > slotAspect) {
                     // Video wider -> Crop X
                     const srcH = videoHeight;
                     const srcW = videoHeight * slotAspect;
                     const srcX = (videoWidth - srcW) / 2;
                     const srcY = 0;
                     renderToCanvas(srcX, srcY, srcW, srcH);
                 } else {
                     // Video taller -> Crop Y
                     const srcW = videoWidth;
                     const srcH = videoWidth / slotAspect;
                     const srcX = 0;
                     const srcY = (videoHeight - srcH) / 2;
                     renderToCanvas(srcX, srcY, srcW, srcH);
                 }
            }

            // Move to next
            currentSlot++;
            updateActiveSlot();
        }

        function renderToCanvas(sx, sy, sw, sh) {
            // Set canvas size to the cropped resolution (high quality)
            canvas.width = sw;
            canvas.height = sh;
            const ctx = canvas.getContext('2d');
            
            // Draw cropped portion
            ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
            
            // Create Image Element
            const dataUrl = canvas.toDataURL('image/png', 0.9);
            images[currentSlot] = dataUrl; // Store for final stitch
            
            const img = document.createElement('img');
            img.src = dataUrl;
            img.className = 'captured-img';
            
            // Add to the slot we just captured
            slots[currentSlot].appendChild(img);
        }

        function undo() {
            if (currentSlot === 0) return;
            
            // If we were finished (Done button showing), hide it
            if (currentSlot === totalSlots) {
                // Just decrement, updateActiveSlot will handle UI
            }
            
            currentSlot--;
            images[currentSlot] = null;
            updateActiveSlot(); // This puts video back into the slot
        }

        function finish() {
            uiControls.classList.add('hidden');
            uiResult.classList.remove('hidden');
            // Stop camera to save battery
            video.pause();
        }

        function downloadCollage() {
            if (images.some(img => !img)) return;

            // Create final canvas
            // Assume all images have same width (since slots are same width), but let's check.
            // We'll use the width of the first image as base.
            
            // We need to load images to get natural dimensions
            const loadProms = images.map(src => {
                return new Promise(resolve => {
                    const i = new Image();
                    i.onload = () => resolve(i);
                    i.src = src;
                });
            });

            Promise.all(loadProms).then(imgs => {
                const totalW = imgs[0].naturalWidth;
                const totalH = imgs.reduce((acc, img) => acc + img.naturalHeight, 0);
                
                canvas.width = totalW;
                canvas.height = totalH;
                const ctx = canvas.getContext('2d');
                
                let y = 0;
                imgs.forEach(img => {
                    // Draw full width, keeping aspect
                    // If dimensions differ slightly due to rounding, stretch to fit width
                    ctx.drawImage(img, 0, y, totalW, img.naturalHeight);
                    y += img.naturalHeight;
                });
                
                // Download
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/jpeg', 0.9);
                link.download = `TriGrid_${Date.now()}.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        }

        function resetApp() {
            images = [null, null, null];
            currentSlot = 0;
            
            // Remove all images
            document.querySelectorAll('.captured-img').forEach(el => el.remove());
            
            uiResult.classList.add('hidden');
            uiControls.classList.remove('hidden');
            
            video.play();
            updateActiveSlot();
        }

        // Init Icons
        lucide.createIcons();

    </script>
</body>
</html>