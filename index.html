
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0, viewport-fit=cover" />
    <title>Tri-Grid Cam</title>
    
    <!-- Mobile Web App Config -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: white;
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
            height: 100dvh; /* Dynamic viewport height */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* The Grid Container */
        #grid-container {
            flex: 1;
            display: grid;
            grid-template-rows: 1fr 1fr 1fr; /* Top, Middle, Bottom */
            width: 100%;
            position: relative;
        }

        /* Individual Slots */
        .grid-slot {
            position: relative;
            overflow: hidden;
            background-color: #1a1a1a;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .grid-slot:last-child {
            border-bottom: none;
        }

        /* The Video Element */
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center center; /* Crucial for WYSIWYG */
            position: absolute;
            inset: 0;
            z-index: 10;
            display: block;
            pointer-events: none;
        }

        /* Captured Image */
        .captured-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center center;
            position: absolute;
            inset: 0;
            z-index: 20;
            display: block;
        }

        /* Active Slot Highlight & Guidelines */
        .slot-active {
            box-shadow: inset 0 0 0 2px rgba(255, 215, 0, 0.5); /* Gold tint for active */
        }
        
        /* Rule of thirds grid for active slot */
        .slot-active::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 30;
            background-image: 
                linear-gradient(to right, rgba(255,255,255,0.2) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 33.33% 33.33%;
            opacity: 0.5;
        }

        /* Animations */
        @keyframes flash {
            0% { background-color: white; opacity: 0; }
            20% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        .flash-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 50;
        }
        .animate-flash {
            animation: flash 0.25s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 40;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* Controls */
        .control-btn {
            pointer-events: auto;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .control-btn:active {
            transform: scale(0.9);
        }
    </style>
</head>
<body>

    <!-- Main Grid -->
    <div id="grid-container">
        <div id="slot-0" class="grid-slot" onclick="handleSlotClick(0)"></div>
        <div id="slot-1" class="grid-slot" onclick="handleSlotClick(1)"></div>
        <div id="slot-2" class="grid-slot" onclick="handleSlotClick(2)"></div>
    </div>

    <!-- Video Element (Detached initially) -->
    <video id="videoElement" autoplay playsinline muted style="display: none;"></video>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 bg-black flex flex-col items-center justify-center pointer-events-auto z-50">
            <div class="mb-8 relative">
                <div class="w-16 h-24 border-2 border-white/30 rounded grid grid-rows-3 overflow-hidden">
                    <div class="bg-white/10 border-b border-white/10"></div>
                    <div class="bg-white/10 border-b border-white/10"></div>
                    <div class="bg-white/10"></div>
                </div>
            </div>
            <h1 class="text-3xl font-bold tracking-tight mb-2">TRI-GRID</h1>
            <p class="text-zinc-400 text-sm mb-10 tracking-wide">垂直三格拼貼相機</p>
            <button onclick="startCamera()" class="bg-white text-black px-10 py-4 rounded-full font-bold text-lg flex items-center gap-2 hover:bg-zinc-200 transition-colors shadow-[0_0_20px_rgba(255,255,255,0.3)]">
                <i data-lucide="camera" class="w-5 h-5"></i>
                開始拍攝
            </button>
        </div>

        <!-- Controls -->
        <div id="controls" class="hidden w-full px-8 py-8 flex justify-between items-center bg-gradient-to-t from-black via-black/50 to-transparent">
            
            <!-- Undo -->
            <button onclick="undo()" class="control-btn text-white/90 p-4 rounded-full bg-white/10 backdrop-blur-md hover:bg-white/20 border border-white/10">
                <i data-lucide="rotate-ccw" class="w-6 h-6"></i>
            </button>

            <!-- Shutter -->
            <button id="shutter-btn" onclick="capture()" class="control-btn relative w-20 h-20 rounded-full border-[5px] border-white/30 flex items-center justify-center shadow-lg">
                <div class="w-16 h-16 bg-white rounded-full transition-transform duration-100"></div>
            </button>

            <!-- Done (Replaces Shutter when full) -->
            <button id="done-btn" onclick="finish()" class="hidden control-btn bg-green-500 text-white w-20 h-20 rounded-full flex items-center justify-center shadow-[0_0_20px_rgba(34,197,94,0.4)]">
                <i data-lucide="check" class="w-10 h-10"></i>
            </button>

            <!-- Spacer/Placeholder -->
            <div class="w-[58px]"></div> 
        </div>

        <!-- Result Actions -->
        <div id="result-actions" class="hidden absolute bottom-0 left-0 right-0 p-6 pb-10 bg-black/90 backdrop-blur-xl border-t border-white/10 flex flex-col gap-3 pointer-events-auto z-50 animate-[slideUp_0.3s_ease-out]">
            <h3 class="text-center text-white font-semibold mb-2">拼貼完成</h3>
            <button onclick="downloadCollage()" class="w-full bg-white text-black py-4 rounded-xl font-bold flex items-center justify-center gap-2 active:scale-[0.98] transition-transform">
                <i data-lucide="download" class="w-5 h-5"></i>
                儲存照片
            </button>
            <button onclick="resetApp()" class="w-full bg-zinc-800 text-white py-4 rounded-xl font-medium flex items-center justify-center gap-2 active:scale-[0.98] transition-transform">
                <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                重新開始
            </button>
        </div>
    </div>

    <!-- Hidden Canvas -->
    <canvas id="processCanvas" class="hidden"></canvas>

    <script>
        // --- State ---
        let stream = null;
        let currentSlot = 0; 
        let images = [null, null, null]; // DataURLs
        const totalSlots = 3;

        // Elements
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('processCanvas');
        const uiStart = document.getElementById('start-screen');
        const uiControls = document.getElementById('controls');
        const uiResult = document.getElementById('result-actions');
        const shutterBtn = document.getElementById('shutter-btn');
        const doneBtn = document.getElementById('done-btn');
        const slots = [
            document.getElementById('slot-0'),
            document.getElementById('slot-1'),
            document.getElementById('slot-2')
        ];

        // Initialize Icons
        lucide.createIcons();

        // --- Core Functions ---

        async function startCamera() {
            try {
                // Request best resolution
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 }, // High res for quality crop
                        height: { ideal: 1080 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                video.style.display = 'block';
                
                video.onloadedmetadata = () => {
                    video.play();
                    uiStart.classList.add('hidden');
                    uiControls.classList.remove('hidden');
                    updateActiveSlot();
                };

            } catch (err) {
                console.error("Camera Error:", err);
                alert('無法啟動相機。請確保使用 Safari (iOS) 或 Chrome (Android) 並允許權限。');
            }
        }

        function updateActiveSlot() {
            // Clean up old video position
            if (video.parentElement) {
                video.parentElement.removeChild(video);
            }

            // Update UI State
            if (currentSlot < totalSlots) {
                const slotEl = slots[currentSlot];
                
                // Remove preview image if any (retaking)
                const existingImg = slotEl.querySelector('.captured-img');
                if (existingImg) existingImg.remove();

                // Move video to slot
                slotEl.appendChild(video);
                video.play();
                
                // Highlight
                slots.forEach(s => s.classList.remove('slot-active'));
                slotEl.classList.add('slot-active');
                
                // Buttons
                shutterBtn.classList.remove('hidden');
                doneBtn.classList.add('hidden');
            } else {
                // Done state
                slots.forEach(s => s.classList.remove('slot-active'));
                video.pause();
                shutterBtn.classList.add('hidden');
                doneBtn.classList.remove('hidden');
            }
        }

        function capture() {
            if (currentSlot >= totalSlots) return;

            const slotEl = slots[currentSlot];
            
            // 1. Visual Effect
            const flash = document.createElement('div');
            flash.className = 'flash-overlay animate-flash';
            slotEl.appendChild(flash);
            setTimeout(() => flash.remove(), 300);

            // 2. WYSIWYG Capture Logic
            // We need to calculate exactly what portion of the video is visible in the slot.
            // CSS object-fit: cover + object-position: center.

            const videoW = video.videoWidth;
            const videoH = video.videoHeight;
            const slotW = slotEl.clientWidth;   // Inner width (no border)
            const slotH = slotEl.clientHeight;  // Inner height

            // Calculate the scaling factor CSS applied to the video
            // Cover means the image is scaled so that BOTH dimensions are >= container
            const scale = Math.max(slotW / videoW, slotH / videoH);

            // The rendered size of the video in pixels on screen
            const renderedW = videoW * scale;
            const renderedH = videoH * scale;

            // Calculate how much of the video is "overflowing" (hidden)
            // Since object-position is center, overflow is distributed evenly
            const overflowX = (renderedW - slotW) / 2;
            const overflowY = (renderedH - slotH) / 2;

            // Map the visible area back to the Source Video Coordinates
            // sourceX = overflowX / scale
            const srcX = overflowX / scale;
            const srcY = overflowY / scale;
            const srcW = slotW / scale;
            const srcH = slotH / scale;

            // 3. Draw to Canvas
            canvas.width = srcW;  // Or scale up for quality? Let's keep 1:1 with source
            canvas.height = srcH;
            const ctx = canvas.getContext('2d');
            
            // Draw only the visible portion
            ctx.drawImage(video, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

            // 4. Save and Show
            const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
            images[currentSlot] = dataUrl;

            const img = document.createElement('img');
            img.src = dataUrl;
            img.className = 'captured-img';
            slotEl.appendChild(img);

            // 5. Advance
            currentSlot++;
            updateActiveSlot();
        }

        function undo() {
            if (currentSlot === 0) return;
            currentSlot--;
            images[currentSlot] = null;
            updateActiveSlot();
        }

        function finish() {
            uiControls.classList.add('hidden');
            uiResult.classList.remove('hidden');
        }

        function downloadCollage() {
            if (images.some(img => !img)) return;

            const loadProms = images.map(src => {
                return new Promise(resolve => {
                    const i = new Image();
                    i.onload = () => resolve(i);
                    i.src = src;
                });
            });

            Promise.all(loadProms).then(imgs => {
                // Calculate total dimensions
                // To avoid jagged edges, we find the max width
                const maxW = Math.max(...imgs.map(i => i.naturalWidth));
                // Total height is sum of heights (scaled to match max width if needed)
                // Since slots are equal height in CSS, source crops should be similar, 
                // but let's be safe and stack them exactly.
                
                let totalH = 0;
                imgs.forEach(img => {
                    // If image width < maxW, we need to scale height proportionally? 
                    // No, assume full width fill.
                    const scale = maxW / img.naturalWidth;
                    totalH += img.naturalHeight * scale;
                });

                canvas.width = maxW;
                canvas.height = totalH;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, maxW, totalH);

                let currentY = 0;
                imgs.forEach(img => {
                    const scale = maxW / img.naturalWidth;
                    const drawH = img.naturalHeight * scale;
                    ctx.drawImage(img, 0, currentY, maxW, drawH);
                    currentY += drawH;
                });

                // Download
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/jpeg', 0.95);
                link.download = `TriGrid_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        }

        function resetApp() {
            // Clear images
            document.querySelectorAll('.captured-img').forEach(el => el.remove());
            images = [null, null, null];
            currentSlot = 0;

            uiResult.classList.add('hidden');
            uiControls.classList.remove('hidden');
            
            video.play();
            updateActiveSlot();
        }
    </script>
</body>
</html>
